{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**知识点**: Stochastic function 从数学上来说是随机泛函。Pyro 样本相对于 Pytorch 样本最大的不同之处是它们有 names, Pyro 的 backend 使用这些 names to uniquely identify sample statements and change their behavior at runtime depending on how the enclosing stochastic function is being used.\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Pyro 模型介绍\n",
    "\n",
    "\n",
    "概率编程的基本单元是 stochastic function, This is an arbitrary Python callable that combines two ingredients:\n",
    "\n",
    "- deterministic Python code; and\n",
    "- primitive stochastic functions that call a random number generator\n",
    "\n",
    "具体来说，随机函数可以是 any Python object with a `__call__()` method, like a function, a method, or a PyTorch `nn.Module`."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "在整个教程和文档中，由于随机函数可用于表示 simplified or abstract descriptions of 数据生成过程，因此我们通常将其称为 stochastic functions *models*。将 models 表示为 stochastic functions 意味着像常规的 Python 可调用对象一样, models can be composed, reused, imported, and serialized."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Table of Contents\n",
    "\n",
    "- [原始随机函数](#原始随机函数)\n",
    "- [一个简单模型](#一个简单模型)\n",
    "- [The pyro.sample Primitive](#The-pyro.sample-Primitive)\n",
    "- [通用概率编程](#通用概率编程)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [],
   "source": [
    "import torch\n",
    "import pyro\n",
    "\n",
    "pyro.set_rng_seed(101)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 原始随机函数 \n",
    "\n",
    "\n",
    "原始随机函数(Primitive stochastic functions, or distributions) 是一类重要的随机函数，我们可以为其显式计算概率 of the outputs given the inputs.  As of PyTorch 0.4 and Pyro 0.2, Pyro uses PyTorch's [distribution library](http://pytorch.org/docs/master/distributions.html). You can also create custom distributions using [transforms](http://pytorch.org/docs/master/distributions.html#module-torch.distributions.transforms).\n",
    "\n",
    "使用 primitive stochastic functions 很简单. 例如, to draw a sample `x` from 标准正态分布 $\\mathcal{N}(0,1)$ we do the following:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "sample tensor(-1.3905)\n",
      "log prob tensor(-1.8857)\n"
     ]
    }
   ],
   "source": [
    "loc = 0.   # mean zero\n",
    "scale = 1. # unit variance\n",
    "normal = torch.distributions.Normal(loc, scale) # create a normal distribution object\n",
    "x = normal.rsample() # draw a sample from N(0,1)\n",
    "print(\"sample\", x)\n",
    "print(\"log prob\", normal.log_prob(x)) # score the sample from N(0,1)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Here, `torch.distributions.Normal` is an instance of the `Distribution` class that takes parameters and provides **sample and score methods**. Pyro's distribution library `pyro.distributions` is a thin wrapper around `torch.distributions` 因为我们想利用 PyTorch's fast tensor math and autograd capabilities during inference."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 一个简单模型\n",
    "\n",
    "所有的 probalistic programs 是通过 primitive functions and deterministic computation 组合得到的。我们最终的目的是要是用 probablistic programming 来模拟真实世界，我们现在从一个具体的例子出发。\n",
    "\n",
    "现在我们有一堆关于每天平均气温和 cloud cover 的数据。我们想 reason about how temperature interacts with whether it was sunny or cloudy. 如下的简单随机函数描述了数据的生成过程：\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/svg+xml": [
       "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n",
       "<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"\n",
       " \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n",
       "<!-- Generated by graphviz version 2.43.0 (0)\n",
       " -->\n",
       "<!-- Title: %3 Pages: 1 -->\n",
       "<svg width=\"217pt\" height=\"44pt\"\n",
       " viewBox=\"0.00 0.00 217.02 44.00\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n",
       "<g id=\"graph0\" class=\"graph\" transform=\"scale(1 1) rotate(0) translate(4 40)\">\n",
       "<title>%3</title>\n",
       "<polygon fill=\"white\" stroke=\"transparent\" points=\"-4,4 -4,-40 213.02,-40 213.02,4 -4,4\"/>\n",
       "<!-- cloudy -->\n",
       "<g id=\"node1\" class=\"node\">\n",
       "<title>cloudy</title>\n",
       "<ellipse fill=\"none\" stroke=\"black\" cx=\"34.18\" cy=\"-18\" rx=\"34.35\" ry=\"18\"/>\n",
       "<text text-anchor=\"middle\" x=\"34.18\" y=\"-13.8\" font-family=\"Times,serif\" font-size=\"14.00\">cloudy</text>\n",
       "</g>\n",
       "<!-- temperature -->\n",
       "<g id=\"node2\" class=\"node\">\n",
       "<title>temperature</title>\n",
       "<ellipse fill=\"none\" stroke=\"black\" cx=\"156.69\" cy=\"-18\" rx=\"52.17\" ry=\"18\"/>\n",
       "<text text-anchor=\"middle\" x=\"156.69\" y=\"-13.8\" font-family=\"Times,serif\" font-size=\"14.00\">temperature</text>\n",
       "</g>\n",
       "<!-- cloudy&#45;&gt;temperature -->\n",
       "<g id=\"edge1\" class=\"edge\">\n",
       "<title>cloudy&#45;&gt;temperature</title>\n",
       "<path fill=\"none\" stroke=\"black\" d=\"M68.42,-18C76.34,-18 85.03,-18 93.77,-18\"/>\n",
       "<polygon fill=\"black\" stroke=\"black\" points=\"94.01,-21.5 104.01,-18 94.01,-14.5 94.01,-21.5\"/>\n",
       "</g>\n",
       "</g>\n",
       "</svg>\n"
      ],
      "text/plain": [
       "<graphviz.files.Source at 0x10bde1210>"
      ]
     },
     "execution_count": 26,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "from graphviz import Source\n",
    "Source('digraph{rankdir=LR; cloudy -> temperature}')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "('cloudy', 46.847618103027344)\n"
     ]
    }
   ],
   "source": [
    "def weather():\n",
    "    cloudy = torch.distributions.Bernoulli(0.3).sample()\n",
    "    cloudy = 'cloudy' if cloudy.item() == 1.0 else 'sunny'\n",
    "    mean_temp = {'cloudy': 55.0, 'sunny': 75.0}[cloudy]\n",
    "    scale_temp = {'cloudy': 10.0, 'sunny': 15.0}[cloudy]\n",
    "    temp = torch.distributions.Normal(mean_temp, scale_temp).rsample()\n",
    "    return cloudy, temp.item()\n",
    "\n",
    "g = weather()\n",
    "print(g)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Let's go through this line-by-line. First, in lines 2 we define a binary random variable 'cloudy', which is given by a draw from the Bernoulli distribution with a parameter of `0.3`. Since the Bernoulli distributions return `0`s or `1`s, in line 3 we convert the value `cloudy` to a string so that return values of `weather` are easier to parse. So according to this model 30% of the time it's cloudy and 70% of the time it's sunny.\n",
    "\n",
    "In lines 4-5 we define the parameters we're going to use to sample the temperature in lines 6. These parameters depend on the particular value of `cloudy` we sampled in line 2. For example, the mean temperature is 55 degrees (Fahrenheit) on cloudy days and 75 degrees on sunny days. Finally we return the two values `cloudy` and `temp` in line 7.\n",
    "\n",
    "\n",
    "但是，`weather` 完全独立于 Pyro - it only calls PyTorch. 我们需要将其转换为 Pyro 程序 if we want to use this model for anything other than sampling fake data. 那么，这个模型除生成假数据还应该能干嘛呢？我们希望 can be composed, reused, imported, and serialized."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## The `pyro.sample` Primitive\n",
    "\n",
    "为了将 `weather` 转换为 Pyro 程序, 我们将会 replace the `torch.distribution`s with `pyro.distribution`s and the `.sample()` and `.rsample()` calls with calls to `pyro.sample`(Pyro的核心语言原语 language primitive 之一). Using `pyro.sample` is as simple as calling a primitive stochastic function with 一个重要的区别:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor(0.9544)\n"
     ]
    }
   ],
   "source": [
    "x = pyro.sample(\"my_sample\", pyro.distributions.Normal(loc, scale))\n",
    "print(x)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Just like a direct call to `torch.distributions.Normal().rsample()`, this returns a sample from the unit normal distribution. 最关键的区别是该样本是有 **names** 的. Pyro的后端使用这些 **names** \n",
    "\n",
    "- to uniquely identify sample statements and \n",
    "- _change their behavior at runtime_ depending on how the enclosing stochastic function is being used. \n",
    "\n",
    "正如我们将看到的，这就是 Pyro 如何实现 various manipulations that underlie inference algorithms. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "我们已经介绍了 `pyro.sample` 和 `pyro.distributions`，现在我们可以将我们的简单模型重写为Pyro程序："
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "('sunny', 94.37557983398438)\n",
      "('sunny', 72.5186767578125)\n",
      "('cloudy', 54.18292999267578)\n"
     ]
    }
   ],
   "source": [
    "def weather():\n",
    "    cloudy = pyro.sample('cloudy', pyro.distributions.Bernoulli(0.3))\n",
    "    cloudy = 'cloudy' if cloudy.item() == 1.0 else 'sunny'\n",
    "    mean_temp = {'cloudy': 55.0, 'sunny': 75.0}[cloudy]\n",
    "    scale_temp = {'cloudy': 10.0, 'sunny': 15.0}[cloudy]\n",
    "    temp = pyro.sample('temp', pyro.distributions.Normal(mean_temp, scale_temp))\n",
    "    return cloudy, temp.item()\n",
    "\n",
    "for _ in range(3):\n",
    "    print(weather())"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Procedurally，`weather()` 仍然是一个non-deterministic Python callable that returns two random samples. Because the randomness is now invoked with `pyro.sample`, however, 它远不止于此。具体来说，`weather()` specifies a joint probability distribution over two named random variables: `cloudy` and `temp`. As such, it defines a probabilistic model that we can reason about using the techniques of probability theory.例如，我们可能会问：如果我观察到70度的温度，多云的可能性有多大？下一个教程将讨论如何提出和回答这类问题。"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 通用概率编程\n",
    "\n",
    "Universality: Stochastic Recursion, Higher-order Stochastic Functions, and Random Control Flow\n",
    "\n",
    "现在我们已经看到了如何定义一个简单的模型。Building off of it is easy. For example:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 建立在 weather 基础上的一个概率程序\n",
    "# weather{cloudy --> temp} --> ice_cream\n",
    "def ice_cream_sales():\n",
    "    cloudy, temp = weather()\n",
    "    expected_sales = 200. if cloudy == 'sunny' and temp > 80.0 else 50.\n",
    "    ice_cream = pyro.sample('ice_cream', pyro.distributions.Normal(expected_sales, 10.0))\n",
    "    return ice_cream"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "(这种模块化是非常强大的) This kind of modularity, familiar to any programmer, is obviously very powerful. 但是它强大到足以包含我们想要表达的所有不同类型的模型吗？\n",
    "\n",
    "It turns out that because Pyro is embedded in Python, stochastic functions can contain arbitrarily complex deterministic Python and randomness can freely affect control flow. 例如，我们可以构造递归函数 that terminate their recursion nondeterministically, provided we take care to pass `pyro.sample` unique sample names whenever it's called. 例如我们可以定义一个几何分布，来计算直到第一次成功之前的失败次数，如下所示：\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "2\n"
     ]
    }
   ],
   "source": [
    "def geometric(p, t=0):\n",
    "    # 该函数表示第 t 次失败之后, 继续尝试直到成功，返回总共失败次数。\n",
    "    x = pyro.sample(\"x_{}\".format(t), pyro.distributions.Bernoulli(p))\n",
    "    if x.item() == 1:\n",
    "        return t\n",
    "    else:\n",
    "        t_update = t+1\n",
    "        return 1 + geometric(p, t_update)\n",
    "    \n",
    "print(geometric(0.5))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Note that the names `x_0`, `x_1`, etc., in `geometric()` are generated dynamically and that different executions can have different numbers of named random variables. \n",
    "\n",
    "我们也可以定义把其他随机函数当成输入或者输出的随机函数："
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/svg+xml": [
       "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n",
       "<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"\n",
       " \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n",
       "<!-- Generated by graphviz version 2.43.0 (0)\n",
       " -->\n",
       "<!-- Title: %3 Pages: 1 -->\n",
       "<svg width=\"371pt\" height=\"98pt\"\n",
       " viewBox=\"0.00 0.00 370.51 98.00\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n",
       "<g id=\"graph0\" class=\"graph\" transform=\"scale(1 1) rotate(0) translate(4 94)\">\n",
       "<title>%3</title>\n",
       "<polygon fill=\"white\" stroke=\"transparent\" points=\"-4,4 -4,-94 366.51,-94 366.51,4 -4,4\"/>\n",
       "<!-- loc -->\n",
       "<g id=\"node1\" class=\"node\">\n",
       "<title>loc</title>\n",
       "<ellipse fill=\"none\" stroke=\"black\" cx=\"154.72\" cy=\"-72\" rx=\"27\" ry=\"18\"/>\n",
       "<text text-anchor=\"middle\" x=\"154.72\" y=\"-67.8\" font-family=\"Times,serif\" font-size=\"14.00\">loc</text>\n",
       "</g>\n",
       "<!-- z1 -->\n",
       "<g id=\"node3\" class=\"node\">\n",
       "<title>z1</title>\n",
       "<ellipse fill=\"none\" stroke=\"black\" cx=\"245.51\" cy=\"-72\" rx=\"27\" ry=\"18\"/>\n",
       "<text text-anchor=\"middle\" x=\"245.51\" y=\"-67.8\" font-family=\"Times,serif\" font-size=\"14.00\">z1</text>\n",
       "</g>\n",
       "<!-- loc&#45;&gt;z1 -->\n",
       "<g id=\"edge1\" class=\"edge\">\n",
       "<title>loc&#45;&gt;z1</title>\n",
       "<path fill=\"none\" stroke=\"black\" d=\"M181.88,-72C190.12,-72 199.37,-72 208.18,-72\"/>\n",
       "<polygon fill=\"black\" stroke=\"black\" points=\"208.23,-75.5 218.23,-72 208.23,-68.5 208.23,-75.5\"/>\n",
       "</g>\n",
       "<!-- z2 -->\n",
       "<g id=\"node4\" class=\"node\">\n",
       "<title>z2</title>\n",
       "<ellipse fill=\"none\" stroke=\"black\" cx=\"245.51\" cy=\"-18\" rx=\"27\" ry=\"18\"/>\n",
       "<text text-anchor=\"middle\" x=\"245.51\" y=\"-13.8\" font-family=\"Times,serif\" font-size=\"14.00\">z2</text>\n",
       "</g>\n",
       "<!-- loc&#45;&gt;z2 -->\n",
       "<g id=\"edge2\" class=\"edge\">\n",
       "<title>loc&#45;&gt;z2</title>\n",
       "<path fill=\"none\" stroke=\"black\" d=\"M175.43,-60.02C187.38,-52.74 202.84,-43.34 216.1,-35.28\"/>\n",
       "<polygon fill=\"black\" stroke=\"black\" points=\"218.13,-38.14 224.86,-29.95 214.49,-32.16 218.13,-38.14\"/>\n",
       "</g>\n",
       "<!-- scale -->\n",
       "<g id=\"node2\" class=\"node\">\n",
       "<title>scale</title>\n",
       "<ellipse fill=\"none\" stroke=\"black\" cx=\"154.72\" cy=\"-18\" rx=\"27.56\" ry=\"18\"/>\n",
       "<text text-anchor=\"middle\" x=\"154.72\" y=\"-13.8\" font-family=\"Times,serif\" font-size=\"14.00\">scale</text>\n",
       "</g>\n",
       "<!-- scale&#45;&gt;z1 -->\n",
       "<g id=\"edge3\" class=\"edge\">\n",
       "<title>scale&#45;&gt;z1</title>\n",
       "<path fill=\"none\" stroke=\"black\" d=\"M175.87,-30.25C187.84,-37.53 203.21,-46.88 216.36,-54.88\"/>\n",
       "<polygon fill=\"black\" stroke=\"black\" points=\"214.69,-57.96 225.05,-60.17 218.32,-51.98 214.69,-57.96\"/>\n",
       "</g>\n",
       "<!-- scale&#45;&gt;z2 -->\n",
       "<g id=\"edge4\" class=\"edge\">\n",
       "<title>scale&#45;&gt;z2</title>\n",
       "<path fill=\"none\" stroke=\"black\" d=\"M182.84,-18C190.89,-18 199.84,-18 208.36,-18\"/>\n",
       "<polygon fill=\"black\" stroke=\"black\" points=\"208.46,-21.5 218.46,-18 208.46,-14.5 208.46,-21.5\"/>\n",
       "</g>\n",
       "<!-- y -->\n",
       "<g id=\"node5\" class=\"node\">\n",
       "<title>y</title>\n",
       "<ellipse fill=\"none\" stroke=\"black\" cx=\"335.51\" cy=\"-45\" rx=\"27\" ry=\"18\"/>\n",
       "<text text-anchor=\"middle\" x=\"335.51\" y=\"-40.8\" font-family=\"Times,serif\" font-size=\"14.00\">y</text>\n",
       "</g>\n",
       "<!-- z1&#45;&gt;y -->\n",
       "<g id=\"edge5\" class=\"edge\">\n",
       "<title>z1&#45;&gt;y</title>\n",
       "<path fill=\"none\" stroke=\"black\" d=\"M270.55,-64.62C279.94,-61.74 290.87,-58.39 301.01,-55.28\"/>\n",
       "<polygon fill=\"black\" stroke=\"black\" points=\"302.26,-58.55 310.79,-52.28 300.21,-51.86 302.26,-58.55\"/>\n",
       "</g>\n",
       "<!-- z2&#45;&gt;y -->\n",
       "<g id=\"edge6\" class=\"edge\">\n",
       "<title>z2&#45;&gt;y</title>\n",
       "<path fill=\"none\" stroke=\"black\" d=\"M270.55,-25.38C279.94,-28.26 290.87,-31.61 301.01,-34.72\"/>\n",
       "<polygon fill=\"black\" stroke=\"black\" points=\"300.21,-38.14 310.79,-37.72 302.26,-31.45 300.21,-38.14\"/>\n",
       "</g>\n",
       "<!-- mu_latent -->\n",
       "<g id=\"node6\" class=\"node\">\n",
       "<title>mu_latent</title>\n",
       "<ellipse fill=\"none\" stroke=\"black\" cx=\"45.47\" cy=\"-72\" rx=\"45.44\" ry=\"18\"/>\n",
       "<text text-anchor=\"middle\" x=\"45.47\" y=\"-67.8\" font-family=\"Times,serif\" font-size=\"14.00\">mu_latent</text>\n",
       "</g>\n",
       "<!-- mu_latent&#45;&gt;loc -->\n",
       "<g id=\"edge7\" class=\"edge\">\n",
       "<title>mu_latent&#45;&gt;loc</title>\n",
       "<path fill=\"none\" stroke=\"black\" d=\"M91.03,-72C99.77,-72 108.84,-72 117.28,-72\"/>\n",
       "<polygon fill=\"black\" stroke=\"black\" points=\"117.55,-75.5 127.55,-72 117.55,-68.5 117.55,-75.5\"/>\n",
       "</g>\n",
       "</g>\n",
       "</svg>\n"
      ],
      "text/plain": [
       "<graphviz.files.Source at 0x10bcb7a10>"
      ]
     },
     "execution_count": 21,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "from graphviz import Source\n",
    "Source('digraph{rankdir=LR; loc, scale -> z1, z2 -> y; mu_latent -> loc}')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "tensor(-0.0618)\n"
     ]
    }
   ],
   "source": [
    "def normal_product(loc, scale):\n",
    "    z1 = pyro.sample(\"z1\", pyro.distributions.Normal(loc, scale))\n",
    "    z2 = pyro.sample(\"z2\", pyro.distributions.Normal(loc, scale))\n",
    "    y = z1 * z2\n",
    "    return y\n",
    "\n",
    "# 可以把 loc 看成某个固定的输入随机函数 mu_latent\n",
    "# 从而得到一个输出是正态随机函数，而不是数值的随机函数。\n",
    "def make_normal_normal():\n",
    "    mu_latent = pyro.sample(\"mu_latent\", pyro.distributions.Normal(0, 1))\n",
    "    fn = lambda scale: normal_product(mu_latent, scale)\n",
    "    return fn\n",
    "\n",
    "print(make_normal_normal()(1.))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Here `make_normal_normal()` is a stochastic function that takes one argument and which, upon execution, generates three named random variables.\n",
    "\n",
    "The fact that Pyro supports arbitrary Python code like this&mdash;iteration, recursion, higher-order functions, etc.&mdash;in conjuction with random control flow means that \n",
    "Pyro 随机函数是 _universal_ ，即它们可用于表示任何可计算的概率分布。\n",
    "正如我们将在后续教程中看到的那样，它难以置信的强大。\n",
    "\n",
    "值得强调的是 that this is one reason why Pyro is built on top of PyTorch: 动态计算图 are an important ingredient in allowing for universal models that can benefit from GPU-accelerated tensor math."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 下一步？\n",
    "\n",
    "我们已经展示了如何使用 stochastic functions 和 primitive distributions 来表示 Pyro中的模型。为了从数据中学习模型并对其进行推理，我们需要 be able to do inference. This is the subject of the [next tutorial](intro_part_ii.ipynb)."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.4"
  },
  "toc": {
   "base_numbering": 1,
   "nav_menu": {},
   "number_sections": true,
   "sideBar": true,
   "skip_h1_title": false,
   "title_cell": "Table of Contents",
   "title_sidebar": "Contents",
   "toc_cell": false,
   "toc_position": {},
   "toc_section_display": true,
   "toc_window_display": true
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
